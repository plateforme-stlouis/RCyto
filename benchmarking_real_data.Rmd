---
title: "Algorithm benchmarking script, main and subpopulations"
subtitle: "Experience `real_02`, sample `5` (`Temoin 4`)"
output:
  html_document:
    number_sections: yes
    toc: yes
    toc_float: yes
    code_folding: hide
    theme: united
    highlight: tango
author: Anna Guadall
params:
  file: "subsample_ff_real_02_Specimen_001_Temoin4_006.fcs.fcs"
  labels: "subsample_labels_real_02_Specimen_001_Temoin4_006.fcs"
  metalabels: "subsample_metalabels_real_02_Specimen_001_Temoin4_006.fcs" 
  sublabels_levels: "sublabels_levels_real_02"
  seed: 42
  clusters: "4,5,8,10,20"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = T, message = FALSE, cache = T)
```

```{r libraries, message=FALSE}
library(FlowSOM)
library(caret)
library(cytofkit)
library(flowPeaks)
library(flowMeans)
library(ggplot2)
library(gridExtra)
library(umap)
library(knitr)
```

# Reading the data
```{r}
# import the fcs file
ff <- flowCore::read.FCS(params$file)

# Importing METALABELS (main populations) and SUBLABELS (subpopulations)
metalabels <- readRDS(params$metalabels) 
sublabels <- readRDS(params$labels) 

# Importing SUBLABELS groups
sublabels_levels <- readRDS(params$sublabels_levels)

# Computing populations' frequencies
main_pops_freq <- (prop.table(table(metalabels)))*100
sub_pops_freq <- (prop.table(table(sublabels)))*100
```

# Number of clusters (For `FlowSOM`)
```{r}
clusters <- c(eval(parse(text = paste("c(", params$clusters, ")", sep = ""))))
```

# Functions
Matching labels and predictions:
```{r}
matching <- function(prediction, labels){
  # cross table
  t <- table(prediction, labels)
  
  # Finding and sorting row maximums:
  max_values <- apply(t, 1, max)
  sorted_max_values <- sort(max_values)
  
  # Finding the cell population (columns) 
  # with a higher number of cells for each cluster (rows):
  m <- apply(t, 1, which.max)
  
  # Empty list 
  matched_preds <- rep("NA", length(prediction))

  # Replacing the numbers of the clusters by the names of the cell types:
  for(i in 1:length(prediction)){
    for(j in 1:length(m)){ # Number of predicted clusters
      if(prediction[i] == names(sorted_max_values)[j]){ 
        matched_preds[i] <- levels(labels)[m[[names(sorted_max_values)[j]]]]
      }
    }
  }

  # Factorize matched predictions 
  matched_preds <- factor(matched_preds, levels = levels(labels))
  
  matched <- list("preds" = matched_preds, "m" = m, "t" = t)
  return(matched)
}
```

Computing the mean F1:
```{r}
mean_f1 <- function(cm, n){
  # Extracting the F1 values
  f1_list <- cm$byClass[1:n,"F1"] # "outliers" must be the last class. Not considered.
  # replacing NAs by zero
  f1_list[is.na(f1_list)] <-  0
  # Computing mean F1 
  return(mean(f1_list))
}
```

# Preaparing results tables
```{r}
mains_f1 <- c()
summ_mains <- data.frame(File = NA, n = 0, Method = NA, Clusters = 0, Mean_F1 = 0)
subs_f1 <- c()
summ_subs <- data.frame(File = NA, n = 0, Method = NA, Clusters = 0, Population = NA, Sub_clusters = 0, Mean_F1 = 0)
```

# Clustering/partitioning
## `FlowSOM`
```{r}
# Parameters
method <- "FlowSOM"
k <- 0

for(i in 1:length(clusters)){
  # META-CLUSTERING
  fs <- FlowSOM(ff, compensate = F,transform = F, scale = F,
                colsToUse = colnames(ff@exprs), nClus = clusters[i], seed = params$seed)
  mc_cell <- fs$metaclustering[fs$FlowSOM$map$mapping[,1]]
  
  ### MAIN POPULATIONS
  # number of main populations, without the outliers
  n <- length(levels(metalabels)) - 1
  
  # MATCHING META-LABELS AND PREDICTIONS (cell level)
  matched <- matching(mc_cell, metalabels)
  main_prediction <-  matched$preds

  # COMPUTING THE CONFUSION MATRIX AND OTHER PERFORMANCE MEASUREMENTS
  cm <- confusionMatrix(data = matched$preds, reference = metalabels)
  # Add the F1 values to a list (will be used to build the summary plot)
  mains_f1 <- c(mains_f1, cm$byClass[1:n, "F1"])

  # COMPUTE THE MEAN F1
  mf1 <- mean_f1(cm, n)
  # Storing the result 
  summ_mains[i,] <- c(params$file, nrow(ff@exprs), method, clusters[i], mf1)
  
  # FOR VISUALIZATION
  # Print the unmatched cross table:
  cat("\n", method, clusters[i], "clusters\n")
  print(matched$t)
  # Print the matched confusion matrix:
  print(cm$table)
  
  #### SPLIT POPULATIONS
  # How many clusters have been assigned to each population?
  table_maxs <- table(matched$m)
  # Which populations have been assigned to more than one cluster?
  split_list <-  names(table_maxs[table_maxs>1])
  split_list <- as.numeric(split_list)
  
  # If there are, start MATCHING SUB-LABELS AND PREDICTORS, one population at a time
  if(length(split_list) != 0){
    for(j in 1:length(split_list)){
    # counter
    k <-  k + 1
    # Selecting the well-predicted cells (i.e., all the T cells matched as T)
    well_pred <- rep(NA, length(metalabels))
    well_pred <- ifelse(main_prediction  == levels(metalabels)[split_list[j]] & metalabels == levels(metalabels)[split_list[j]], TRUE, FALSE)
    
    # MATCHING SUBLABELS AND PREDICTIONS
    # Only the sublabels for the population
    # Only the levels for those sublabels
    sublevels <- sublabels_levels[[levels(metalabels)[split_list[j]]]]
    matched <- matching(mc_cell[well_pred], 
                  factor(sublabels[well_pred], levels = sublevels))
    
    # COMPUTING THE CONFUSION MATRIX AND OTHER PERFORMANCE MEASUREMENTS
    cm <- confusionMatrix(data = matched$preds, 
                          reference = factor(sublabels[well_pred], levels = sublevels))
    # Add the F1 values to a list (will be used to build the summary plot)
    subs_f1 <- c(subs_f1, cm$byClass[, "F1"])
    
    # COMPUTE THE MEAN F1
    # number of subpopulations
    n <- length(sublevels)
    mf1 <- mean_f1(cm, n)
    # Storing the result
    summ_subs[k,] <- c(params$file, nrow(ff@exprs), method, clusters[i], levels(metalabels)[split_list[j]], table_maxs[table_maxs>1][[j]], mf1)
    
    # FOR VISUALIZATION
    print(cm$table)
    }
  }
}
```

## `RphenoGraph`
```{r}
# Parameters
method <- "RPhenograph"
k <- nrow(summ_subs)

# CLUSTERING
pred <- Rphenograph(ff@exprs) # default k = 30 nearest neighbours

### MAIN POPULATIONS
# number of main populations, without the outliers
n <- length(levels(metalabels)) - 1
  
# MATCHING LABELS AND PREDICTIONS
matched <- matching(pred$membership, metalabels)
main_prediction <-  matched$preds

# COMPUTING THE CONFUSION MATRIX AND OTHER PERFORMANCE MEASUREMENTS
cm <- confusionMatrix(data = matched$preds, reference = metalabels)
# Add the F1 values to a list (will be used to build the summary plot)
mains_f1 <- c(mains_f1, cm$byClass[1:n, "F1"])

# COMPUTE THE MEAN F1
mf1 <- mean_f1(cm, n)
# Storing the result 
nc <- length(matched$m) # predicted clusters
summ_mains[(nrow(summ_mains)+1),] <- c(params$file, nrow(ff@exprs), method, nc, mf1)
  
# FOR VISUALIZATION
print(matched$t)
print(cm$table)

#### SPLIT POPULATIONS
  # How many clusters have been assigned to each population?
  table_maxs <- table(matched$m)
  # Which populations have been assigned to more than one cluster?
  split_list <-  names(table_maxs[table_maxs>1])
  split_list <- as.numeric(split_list)
  
  # If there are, start MATCHING SUB-LABELS AND PREDICTORS, one population at a time
  if(length(split_list) != 0){
    for(j in 1:length(split_list)){
    # counter
    k <-  k + 1
    # Selecting the well-predicted cells (i.e., all the T cells matched as T)
    well_pred <- rep(NA, length(metalabels))
    well_pred <- ifelse(main_prediction  == levels(metalabels)[split_list[j]] & metalabels == levels(metalabels)[split_list[j]], TRUE, FALSE)
    
    # MATCHING SUBLABELS AND PREDICTIONS
    # Only the sublabels for the population
    # Only the levels for those sublabels
    sublevels <- sublabels_levels[[levels(metalabels)[split_list[j]]]]
    matched <- matching(mc_cell[well_pred], 
                  factor(sublabels[well_pred], levels = sublevels))
    
    # COMPUTING THE CONFUSION MATRIX AND OTHER PERFORMANCE MEASUREMENTS
    cm <- confusionMatrix(data = matched$preds, 
                          reference = factor(sublabels[well_pred], levels = sublevels))
    # Add the F1 values to a list (will be used to build the summary plot)
    subs_f1 <- c(subs_f1, cm$byClass[, "F1"])
    
    # COMPUTE THE MEAN F1
    # number of subpopulations
    n <- length(sublevels)
    mf1 <- mean_f1(cm, n)
    # Storing the result
    summ_subs[k,] <- c(params$file, nrow(ff@exprs), method, nc, levels(metalabels)[split_list[j]], table_maxs[table_maxs>1][[j]], mf1)
    
    # FOR VISUALIZATION
    print(cm$table)
    }
  }
```

## UMAP DIMENSIONALITY REDUCTION
```{r}
set.seed(params$seed)
reduction <- umap(ff@exprs, random_state = params$seed)
colnames(reduction$layout) <- c("UMAP_1", "UMAP_2")
```

### `flowPeaks` 
```{r}
# Parameters
method <- "UMAP + flowPeaks"
k <- nrow(summ_subs)

# CLUSTERING
red_data <- as.matrix(reduction$layout)
colnames(red_data) <- c("tsne_1", "tsne_2")
pred <-  flowPeaks(red_data)

### MAIN POPULATIONS
# number of main populations, without the outliers
n <- length(levels(metalabels)) - 1
  
# MATCHING LABELS AND PREDICTIONS
matched <- matching(pred$peaks.cluster, metalabels)
main_prediction <-  matched$preds

# COMPUTING THE CONFUSION MATRIX AND OTHER PERFORMANCE MEASUREMENTS
cm <- confusionMatrix(data = matched$preds, reference = metalabels)
# Add the F1 values to a list (will be used to build the summary plot)
mains_f1 <- c(mains_f1, cm$byClass[1:n, "F1"])

# COMPUTE THE MEAN F1
mf1 <- mean_f1(cm, n)
# Storing the result 
nc <- length(matched$m) # predicted clusters
summ_mains[(nrow(summ_mains)+1),] <- c(params$file, nrow(ff@exprs), method, nc, mf1)
  
# FOR VISUALIZATION
print(matched$t)
print(cm$table)

#### SPLIT POPULATIONS
  # How many clusters have been assigned to each population?
  table_maxs <- table(matched$m)
  # Which populations have been assigned to more than one cluster?
  split_list <-  names(table_maxs[table_maxs>1])
  split_list <- as.numeric(split_list)
  
  # If there are, start MATCHING SUB-LABELS AND PREDICTORS, one population at a time
  if(length(split_list) != 0){
    for(j in 1:length(split_list)){
    # counter
    k <-  k + 1
    # Selecting the well-predicted cells (i.e., all the T cells matched as T)
    well_pred <- rep(NA, length(metalabels))
    well_pred <- ifelse(main_prediction  == levels(metalabels)[split_list[j]] & metalabels == levels(metalabels)[split_list[j]], TRUE, FALSE)
    
    # MATCHING SUBLABELS AND PREDICTIONS
    # Only the sublabels for the population
    # Only the levels for those sublabels
    sublevels <- sublabels_levels[[levels(metalabels)[split_list[j]]]]
    matched <- matching(mc_cell[well_pred], 
                  factor(sublabels[well_pred], levels = sublevels))
    
    # COMPUTING THE CONFUSION MATRIX AND OTHER PERFORMANCE MEASUREMENTS
    cm <- confusionMatrix(data = matched$preds, 
                          reference = factor(sublabels[well_pred], levels = sublevels))
    # Add the F1 values to a list (will be used to build the summary plot)
    subs_f1 <- c(subs_f1, cm$byClass[, "F1"])
    
    # COMPUTE THE MEAN F1
    # number of subpopulations
    n <- length(sublevels)
    mf1 <- mean_f1(cm, n)
    # Storing the result
    summ_subs[k,] <- c(params$file, nrow(ff@exprs), method, nc, levels(metalabels)[split_list[j]], table_maxs[table_maxs>1][[j]], mf1)
    
    # FOR VISUALIZATION
    print(cm$table)
    }
  }
```


### `ClusterX` 
```{r}
# Parameters
method <- "UMAP + ClusterX"
k <- nrow(summ_subs)

# CLUSTERING
pred <- cytof_cluster(reduction$layout, method = "ClusterX")

### MAIN POPULATIONS
# number of main populations, without the outliers
n <- length(levels(metalabels)) - 1
  
# MATCHING LABELS AND PREDICTIONS
matched <- matching(pred, metalabels)
# Storing the results
main_prediction <-  matched$preds

# COMPUTING THE CONFUSION MATRIX AND OTHER PERFORMANCE MEASUREMENTS
cm <- confusionMatrix(data = matched$preds, reference = metalabels)
# Add the F1 values to a list (will be used to build the summary plot)
mains_f1 <- c(mains_f1, cm$byClass[1:n, "F1"])

# COMPUTE THE MEAN F1
mf1 <- mean_f1(cm, n)
# Storing the result 
nc <- length(matched$m) # predicted clusters
summ_mains[(nrow(summ_mains)+1),] <- c(params$file, nrow(ff@exprs), method, nc, mf1)
  
# FOR VISUALIZATION
print(matched$t)
print(cm$table)

#### SPLIT POPULATIONS
  # How many clusters have been assigned to each population?
  table_maxs <- table(matched$m)
  # Which populations have been assigned to more than one cluster?
  split_list <-  names(table_maxs[table_maxs>1])
  split_list <- as.numeric(split_list)
  
  # If there are, start MATCHING SUB-LABELS AND PREDICTORS, one population at a time
  if(length(split_list) != 0){
    for(j in 1:length(split_list)){
    # counter
    k <-  k + 1
    # Selecting the well-predicted cells (i.e., all the T cells matched as T)
    well_pred <- rep(NA, length(metalabels))
    well_pred <- ifelse(main_prediction  == levels(metalabels)[split_list[j]] & metalabels == levels(metalabels)[split_list[j]], TRUE, FALSE)
    
    # MATCHING SUBLABELS AND PREDICTIONS
    # Only the sublabels for the population
    # Only the levels for those sublabels
    sublevels <- sublabels_levels[[levels(metalabels)[split_list[j]]]]
    matched <- matching(mc_cell[well_pred], 
                  factor(sublabels[well_pred], levels = sublevels))
    
    # COMPUTING THE CONFUSION MATRIX AND OTHER PERFORMANCE MEASUREMENTS
    cm <- confusionMatrix(data = matched$preds, 
                          reference = factor(sublabels[well_pred], levels = sublevels))
    # Add the F1 values to a list (will be used to build the summary plot)
    subs_f1 <- c(subs_f1, cm$byClass[, "F1"])
    
    # COMPUTE THE MEAN F1
    # number of subpopulations
    n <- length(sublevels)
    mf1 <- mean_f1(cm, n)
    # Storing the result
    summ_subs[k,] <- c(params$file, nrow(ff@exprs), method, nc, levels(metalabels)[split_list[j]], table_maxs[table_maxs>1][[j]], mf1)
    
    # FOR VISUALIZATION
    print(cm$table)
    }
  }
```  

# Evaluation
## Main populations
```{r}
# mean F1 , main populations
summ_mains[,5] <- as.numeric(summ_mains[,5])
kable(summ_mains[,3:5], digits = 3)
```

```{r, eval = T}
# export results (mean F1)
write.table(summ_mains, 
            file = "../results_real_f1/summ_mains.txt", append = T, sep = "\t", row.names = F, col.names = F)
```

```{r}
# preparing for plot
np <- length(levels(metalabels))-1 # number of main populations

method <- c(paste("FlowSOM", clusters, sep = "_"), "RPhenograph", "UMAP + flowPeaks", "UMAP + ClusterX")
method <- factor(method, levels = c("RPhenograph", "UMAP + flowPeaks", "UMAP + ClusterX", paste("FlowSOM", clusters, sep = "_")))

class <- factor(levels(metalabels)[1:np], levels = levels(metalabels)[1:np])
df <- data.frame(class = rep(class, length(method)), method = rep(method, each = np), 
                 F1 = mains_f1, frequencies = rep(main_pops_freq[1:np], length(method)))
```

```{r, fig.width=7, fig.height=7}
ggplot(df, aes(class, F1)) + geom_point(aes(size = frequencies, color = frequencies)) + 
  coord_flip() + ggtitle("F1 scores") + ylim(0,1) + facet_wrap(.~method) + 
  scale_color_gradient2(low = "#820000", mid = "#ff00e8", high = "#2e00ff", midpoint = (max(main_pops_freq)-min(main_pops_freq))/2)
```

```{r}
kable(main_pops_freq, digits = 3)
```

```{r, eval = T}
# export plot
png(paste("../results_real_f1/graph_MAINS_", params$file, ".png", sep = ""), res=150, width = 1400, height = 1400)
ggplot(df, aes(class, F1)) + geom_point(aes(size = frequencies, color = frequencies)) + 
  coord_flip() + ggtitle("F1 scores (main populations)") + ylim(0,1) + facet_wrap(.~method) + 
  scale_color_gradient2(low = "#820000", mid = "#ff00e8", high = "#2e00ff", midpoint = (max(main_pops_freq)-min(main_pops_freq))/2)
dev.off()
```

## Subpopulations
```{r}
# mean F1 , subpopulations
summ_subs[,7] <- as.numeric(summ_subs[,7])
kable(summ_subs[,3:7], digits = 3)
```

```{r, eval = T}
# export results (mean F1)
write.table(summ_subs, 
            file = "../results_real_f1/summ_subs.txt", append = T, sep = "\t", row.names = F, col.names = F)
```

```{r}
# preparing for plot
method <- factor(rep(paste(summ_subs[,3], summ_subs[,4]), each = 4)) # IN THIS CAS THIS WORKS BECAUSE ALL THE MAIN POPULATIONS HAVE 4 SUBCLASSES
class <- unlist(sublabels_levels[summ_subs[,5]])
main_class <- rep(summ_subs[,5], each = 4) # IN THIS CAS THIS WORKS BECAUSE ALL THE MAIN POPULATIONS HAVE 4 SUBCLASSES
#levels(method)
```

```{r}
method <- factor(method, levels = c(levels(method)[6:8], levels(method)[3:5], levels(method)[1:2]))
df <- data.frame(class = class, method = method, F1 = subs_f1, main_class = main_class)
```

```{r, fig.width=7, fig.height=12}
ggplot(df, aes(class, F1)) + geom_point(aes(color = main_class)) + 
  coord_flip() + ggtitle("F1 scores") + ylim(0,1) + facet_wrap(.~method) 
```

```{r, eval = T}
# export plot
png(paste("../results_real_f1/graph_SUBS_", params$file, ".png", sep = ""), res=150, width = 1400, height = 2400)
ggplot(df, aes(class, F1)) + geom_point(aes(color = main_class)) + 
  coord_flip() + ggtitle("F1 scores (subpopulations)") + ylim(0,1) + facet_wrap(.~method) 
dev.off()
```

```{r}
kable(sub_pops_freq, digits = 3)
```


