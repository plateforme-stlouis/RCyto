---
title: "RPhenograph - test_05"
output:
  html_document:
    number_sections: yes
    theme: journal
    toc: yes
    toc_float: yes
author: Anna Guadall
params:
  file: "ff_05_2019-04-18.fcs"
  labels: "labels_05_2019-04-18"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
```

Rphenograph is included in the package cytofkit. It can also be downloaded from the JinmiaoChenLab at GitHub.

# Reading the data
```{r}
ff <- flowCore::read.FCS(params$file)

# Import the labels
labels <- readRDS(params$labels)

# number of populations
c <- length(levels(labels))
```

```{r}
# expression matrix is in ff@exprs
dim(ff@exprs)
```

```{r}
is.matrix(ff@exprs)
```

# RphenoGraph partitioning
```{r}
library(cytofkit)
rphe <- Rphenograph(ff@exprs) # default k = 30 nearest neighbours
```

```{r}
#print(rphe)
```

```{r}
length(rphe)
```

```{r}
# returns a numeric vector, one number for each vertex in the graph that was the input of the community detection
#rphe$membership
```

```{r}
# returns a numeric scalar
rphe$modularity
# ????
```

```{r}
# returns a character scalar
rphe$algorithm
```

```{r}
table(rphe$membership)
```


# Evaluating the performance
Matching the labels with the predictions:

```{r, message=FALSE}
# Cross table (CLUSTERING)
(t <- table(rphe$membership, labels))
```

```{r}
(max_values <- apply(t, 2, max))
```

```{r}
(sorted_max_values <- sort(max_values))
```

Finding the maximum number of each cell type (columns) on each cluster (rows):
```{r}
(m <- apply(t, 2, which.max))
```

Replacing the numbers of the clusters by the names of the cell types:
```{r}
for(i in 1:length(rphe$membership)){
  for(j in 1:c){
    n <- names(sorted_max_values)[j] # we compare to the sorted names
     if(rphe$membership[i] == m[n]){ 
        rphe$membership[i] <- n
    }
  }
}

table(rphe$membership, labels)
```

## NEW MATCHING PROCEDURE
In previous work, all the unassigned clusters would have been labelled as unknowns. Now, we would like now to assign the _extra clusters_ to their corresponding populations. In this case, we can easily see that the first 5 rows of the cross table (predicted clusters 7, 9, 11, 12 and 13) they all belong to the T4 population. Some cells have been classed incorrectly (for example, 22 cells from cluster 12 actually belong to the U3 population). Thus, we will assign each _extra cluster_ to the population with the higher amount of correctly classified cells. I do not want to lose the _extra clusters_ on `rphe$membership`, thus, I will create another element:

```{r}
main_match <- rphe$membership
```

Which clusters are not in the labels list?
```{r}
library(Hmisc) # includes %nin% operator (not in)
(extras <-  names(table(rphe$membership[rphe$membership %nin% labels])))
```

```{r}
(t_ext <-  t[extras,])
```

Finding and sorting de maxs:
```{r}
(ext_max_values <- apply(t_ext, 1, max))
```

```{r}
(sorted_ext_max_values <- sort(ext_max_values))
```

Finding the cell population (columns) which a higher number of cells on each extra cluster (rows):
```{r}
(m_ext <- apply(t_ext, 1, which.max))
```

Factorizing
```{r}
extras <- as.factor(extras)
levels(extras)
```

Replacing the numbers of the _extra clusters_ by the names of the cell types:
```{r}
for(i in 1:length(rphe$membership)){
  for(j in 1:length(extras)){
      if(rphe$membership[i] == names(sorted_ext_max_values)[j]){
        main_match[i] <- levels(labels)[m_ext[[names(sorted_ext_max_values)[j]]]] 
    }
  }
}

table(main_match, labels)
```


Computing the confusion matrix and other performance measurements:
```{r}
library(caret)
main_match <- factor(main_match, levels = levels(labels))
(cm <- confusionMatrix(data = main_match, reference = labels))
```

```{r}
cm$byClass
```


```{r}
dades <- cbind(as.data.frame(ff@exprs), labels, main_match)
ggplot(dades, aes(x = CD3, y = CD19, col = labels, shape = main_match))  + 
  geom_point(size = 3) + scale_shape_manual(values = c(0:10)) +
  theme(legend.position = "bottom")
```

```{r}
ggplot(dades, aes(x = CD8, y = CD56, col = labels, shape = main_match))  + 
  geom_point(size = 3) + scale_shape_manual(values = c(0:10)) +
  theme(legend.position = "bottom")
```





